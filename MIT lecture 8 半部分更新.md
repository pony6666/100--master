## 面向对象的编程 ##

面向对象编程的关键是将*对象看作数据和可以在数据上执行的方法的集合*

每个对象都有类型，定义了程序能够在这个对象上执行的操作。

**抽象数据类型**是一个由对象以及对象上的操作组成的集合，对象和操作被捆绑成为一个整体，可以从程序的一个部分传递到另一个部分。

这些操作的规范定义了抽象数据类型和程序其他部分之间的**接口**。接口定义了操作的行为，即它们做什么，但没有说明如何去做。于是，接口建立了一个**抽象边界**，将程序的其他部分与实现类型抽象的数据结构。

编程的时候，要使程序易于修改，以控制程序复杂度。**分解和抽象**就能完成这个任务。

抽象的关键是隐藏合适的细节，分解能够使程序具有结构。

上面的内容终于让我理解了Github上的有的一项功能有那么多的文件的原因了，能够使程序以于修改，能够使维护的更加方便。

类的定义会创建一个type类型的对象，并将这个类的对象与一组instancemethod类型的对象关联在一块。

我现在认为类的定义有点像是我们归纳总结好的一个东西，里面有相同的属性。

类定义中存中存在一个函数定义时，被定义的函数成为**方法**


姓名： 马林

学习内容：lecture8部分内容

打卡天数：第25天

总共用时：约0.4h

6/26/2019 1:02:45 PM 

类支持两种操作

- 实例化：创建类的实例。例如，语句s=Intset()会创建一个新的IntSet类型的对象，这个对象就成为Intset类的一个实例
- 属性引用：通过点标记访问与关联的属性。例如，s.member表示与IntSet类型的实例s关联的member方法。

每个类的定义都保留字class开头，后面是类名和其他信息，表明这个类是如何与其他类关联的。本例子中，第一行代码表示InSet类的一个子类。

Python中有一些特殊的方法名，这些名称的开头和结尾都是两个下滑线。我们首先介绍_init_,只要是一个类被实例化，就会调用该类中定义的_init_方法。执行以下代码时：
s=IntSet()
解释器会创建一个IntSet类型的新实例，然后调用IntSet._init_方法，并使用新创建的对象那个作为实参，绑定到形参self上。IntSet._init_被调用时，会创建一个list类型的对象vals,这个对象会成为新创建的IntSet类型的一部分。 

## 对象 ##

- Python支持许多不同类型的数据

1234 	3.14159 	"Hello"	 	[1, 5, 7, 11, 13]		{"CA": "California", "MA": "Massachusetts"} 

- 每个都是一个**对象**，每个对象都有：
	- 一个类型
	- 一个内部**数据表示**（原始的或复合的）
	- 与对象**交互**的一组过程

- 对象是类型的**实例**
	- 1234是int的实例
	- “hello”是字符串的实例


## 面向对象的程序设计（OOP） ##

- PYTHON中的一切都是一个对象（并且有一个类型）
- 可以创建某种类型的新对象
- 可以操纵对象
- 可以摧毁对象
	- 显式使用del或只是“forget”它们
	- python系统将回收被破坏或无法访问的对象 - 称为“垃圾收集”


## 什么是对象？ ##

对象是一种捕获......的抽象数据

1. 内部代表
- 通过数据属性

2. 用于与对象交互的接口
- 通过方法（又称程序/功能） 
- 定义行为但隐藏实现


## 示例：[1,2,3,4]具有类型列表 ##

- 列表如何在**内部表示**？ 链接的单元格列表

- 如何**操纵**列表？
	-  L[i], L[i:j], + 
	-  len(), min(), max(), del(L[i]) 
	-  L.append(),L.extend(),L.count(),L.index(), L.insert(),L.pop(),L.remove(),L.reverse(), L.sort() 

-  内部代表应该是私人的

- 如果直接操作内部表示，可能会损害正确的行为


## OOP的优点 ##

- **将数据**与通过定义良好的接口处理它们的过程**捆绑**在一起
- 分而治之的发展
	- 分别实现和测试每个类的行为
	- 增加模块化降低了复杂性
- 类使**重用**代码变得容易
	- 许多Python模块定义新类
	- 每个类都有一个单独的环境（函数名称没有冲突）
	- 继承允许子类重新定义或扩展超类行为的选定子集

## 使用类创建和使用自己的类型 ##

- 区分**创建类**和**使用类**的实例
- **创建**类涉及到
	- 定义类名
	- 定义类属性
	- 例如，有人编写代码来实现列表类
- **使用**该类涉及
	- 创建对象的新**实例**
	- 对实例进行操作
	- 例如，L = [1,2]和len（L）

## 定义你自己的类型 ##

使用class关键字来定义新类型

![](http://https://github.com/pony6666/100--master/blob/master/MIT%20解释图/类.PNG)
*下面插入一个图片*

- 类似于def，缩进代码，用于指示哪些语句是**类定义**的一部分
- 单词对象意味着Coordinate是一个Python对象并**继承**了它的所有属性（继承下一讲）
	- Coordinate是对象的子类
	- object是Coordinate的超类

## 什么是属性？ ##

- **“属于”**类的数据和程序

**数据属性**
- 将数据视为构成该类的其他对象
- 例如，坐标由两个数字组成

**方法**（程序属性）
- 将方法视为仅适用于此类的函数
- 如何与对象进行交互
- 例如，您可以定义两个坐标对象之间的距离，但两个列表对象之间的距离没有意义

## 定义如何创建一个类的实例 ##
- 首先要定义**如何创建对象**的实例
- 使用一个名为**__init__的特殊方法**来初始化一些数据属性

![](http://https://github.com/pony6666/100--master/blob/master/MIT%20解释图/怎样定义类.PNG)
*插一些图片*

## 实际创建一个类的实例 ##
实例的数据属性称为**实例变量**
不为self提供参数，Python会自动执行此操作

下面这段代码的数学思想就是勾股定理

	#################
	## EXAMPLE: simple Coordinate class
	#################
	class Coordinate(object):
	    """ 由x和y值组成的坐标 """
	    def __init__(self, x, y):
	        """ 设置x和y值 """
	        self.x = x
	        self.y = y
	    def __str__(self):
	        """ 返回self的字符串表示形式 """
	        return "<" + str(self.x) + "," + str(self.y) + ">"
	    def distance(self, other):
	        """ 返回两点之间的欧氏距离 """
	        x_diff_sq = (self.x-other.x)**2
	        y_diff_sq = (self.y-other.y)**2
	        return (x_diff_sq + y_diff_sq)**0.5
	
	
	c = Coordinate(3,4)
	origin = Coordinate(0,0)
	print(c.x, origin.x)
	print(c.distance(origin))
	print(Coordinate.distance(c, origin))
	print(origin.distance(c))
	print(c)


## 什么是方法？  ##

- 程序属性，就像**只适用于此类的函数**一样
- Python总是将对象作为第一个参数传递
	- 约定是使用**self**作为所有方法的第一个参数的名称

- “.”运算符用于访问任何属性
	- 对象的数据属性
	- 对象的方法


姓名： 马林

学习内容：lecture 8 一半内容

打卡天数：第26天

总共用时：约2h

欢迎学过的小伙伴们观看和提意见，温故而知新。欢迎即将要学到这节课的小伙伴浏览预习。
