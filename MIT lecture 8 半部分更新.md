## 面向对象的编程 ##

面向对象编程的关键是将*对象看作数据和可以在数据上执行的方法的集合*

每个对象都有类型，定义了程序能够在这个对象上执行的操作。

**抽象数据类型**是一个由对象以及对象上的操作组成的集合，对象和操作被捆绑成为一个整体，可以从程序的一个部分传递到另一个部分。

这些操作的规范定义了抽象数据类型和程序其他部分之间的**接口**。接口定义了操作的行为，即它们做什么，但没有说明如何去做。于是，接口建立了一个**抽象边界**，将程序的其他部分与实现类型抽象的数据结构。

编程的时候，要使程序易于修改，以控制程序复杂度。**分解和抽象**就能完成这个任务。

抽象的关键是隐藏合适的细节，分解能够使程序具有结构。

上面的内容终于让我理解了Github上的有的一项功能有那么多的文件的原因了，能够使程序以于修改，能够使维护的更加方便。

类的定义会创建一个type类型的对象，并将这个类的对象与一组instancemethod类型的对象关联在一块。

我现在认为类的定义有点像是我们归纳总结好的一个东西，里面有相同的属性。

类定义中存中存在一个函数定义时，被定义的函数成为**方法**


姓名： 马林

学习内容：lecture8部分内容

打卡天数：第25天

总共用时：约0.4h

6/26/2019 1:02:45 PM 

类支持两种操作

- 实例化：创建类的实例。例如，语句s=Intset()会创建一个新的IntSet类型的对象，这个对象就成为Intset类的一个实例
- 属性引用：通过点标记访问与关联的属性。例如，s.member表示与IntSet类型的实例s关联的member方法。

每个类的定义都保留字class开头，后面是类名和其他信息，表明这个类是如何与其他类关联的。本例子中，第一行代码表示InSet类的一个子类。

Python中有一些特殊的方法名，这些名称的开头和结尾都是两个下滑线。我们首先介绍_init_,只要是一个类被实例化，就会调用该类中定义的_init_方法。执行以下代码时：
s=IntSet()
解释器会创建一个IntSet类型的新实例，然后调用IntSet._init_方法，并使用新创建的对象那个作为实参，绑定到形参self上。IntSet._init_被调用时，会创建一个list类型的对象vals,这个对象会成为新创建的IntSet类型的一部分。 

## 对象 ##

- Python支持许多不同类型的数据

1234 	3.14159 	"Hello"	 	[1, 5, 7, 11, 13]		{"CA": "California", "MA": "Massachusetts"} 

- 每个都是一个**对象**，每个对象都有：
	- 一个类型
	- 一个内部**数据表示**（原始的或复合的）
	- 与对象**交互**的一组过程

- 对象是类型的**实例**
	- 1234是int的实例
	- “hello”是字符串的实例


## 面向对象的程序设计（OOP） ##

- PYTHON中的一切都是一个对象（并且有一个类型）
- 可以创建某种类型的新对象
- 可以操纵对象
- 可以摧毁对象
	- 显式使用del或只是“forget”它们
	- python系统将回收被破坏或无法访问的对象 - 称为“垃圾收集”


## 什么是对象？ ##

对象是一种捕获......的抽象数据

1. 内部代表
- 通过数据属性

2. 用于与对象交互的接口
- 通过方法（又称程序/功能） 
- 定义行为但隐藏实现


## 示例：[1,2,3,4]具有类型列表 ##

- 列表如何在**内部表示**？ 链接的单元格列表

- 如何**操纵**列表？
	-  L[i], L[i:j], + 
	-  len(), min(), max(), del(L[i]) 
	-  L.append(),L.extend(),L.count(),L.index(), L.insert(),L.pop(),L.remove(),L.reverse(), L.sort() 

-  内部代表应该是私人的

- 如果直接操作内部表示，可能会损害正确的行为


## OOP的优点 ##

- **将数据**与通过定义良好的接口处理它们的过程**捆绑**在一起
- 分而治之的发展
	- 分别实现和测试每个类的行为
	- 增加模块化降低了复杂性
- 类使**重用**代码变得容易
	- 许多Python模块定义新类
	- 每个类都有一个单独的环境（函数名称没有冲突）
	- 继承允许子类重新定义或扩展超类行为的选定子集

## 使用类创建和使用自己的类型 ##

- 区分**创建类**和**使用类**的实例
- **创建**类涉及到
	- 定义类名
	- 定义类属性
	- 例如，有人编写代码来实现列表类
- **使用**该类涉及
	- 创建对象的新**实例**
	- 对实例进行操作
	- 例如，L = [1,2]和len（L）

## 定义你自己的类型 ##

使用class关键字来定义新类型

![](http://https://github.com/pony6666/100--master/blob/master/MIT%20解释图/类.PNG)
*下面插入一个图片*

- 类似于def，缩进代码，用于指示哪些语句是**类定义**的一部分
- 单词对象意味着Coordinate是一个Python对象并**继承**了它的所有属性（继承下一讲）
	- Coordinate是对象的子类
	- object是Coordinate的超类

## 什么是属性？ ##

- **“属于”**类的数据和程序

**数据属性**
- 将数据视为构成该类的其他对象
- 例如，坐标由两个数字组成

**方法**（程序属性）
- 将方法视为仅适用于此类的函数
- 如何与对象进行交互
- 例如，您可以定义两个坐标对象之间的距离，但两个列表对象之间的距离没有意义

## 定义如何创建一个类的实例 ##
- 首先要定义**如何创建对象**的实例
- 使用一个名为**__init__的特殊方法**来初始化一些数据属性

![](http://https://github.com/pony6666/100--master/blob/master/MIT%20解释图/怎样定义类.PNG)
*插一些图片*

## 实际创建一个类的实例 ##
实例的数据属性称为**实例变量**
不为self提供参数，Python会自动执行此操作

下面这段代码的数学思想就是勾股定理

	#################
	## EXAMPLE: simple Coordinate class
	#################
	class Coordinate(object):
	    """ 由x和y值组成的坐标 """
	    def __init__(self, x, y):
	        """ 设置x和y值 """
	        self.x = x
	        self.y = y
	    def __str__(self):
	        """ 返回self的字符串表示形式 _str_是特殊方法的名称	一定返回一个字符串"""
	        return "<" + str(self.x) + "," + str(self.y) + ">"
	    def distance(self, other):
	        """ 返回两点之间的欧氏距离 """
	        x_diff_sq = (self.x-other.x)**2
	        y_diff_sq = (self.y-other.y)**2
	        return (x_diff_sq + y_diff_sq)**0.5
	
	
	c = Coordinate(3,4)
	origin = Coordinate(0,0)
	print(c.x, origin.x)
	print(c.distance(origin))
	print(Coordinate.distance(c, origin))
	print(origin.distance(c))
	print(c)


## 什么是方法？  ##

- 程序属性，就像**只适用于此类的函数**一样
- Python总是将对象作为第一个参数传递
	- 约定是使用**self**作为所有方法的第一个参数的名称

- “.”运算符用于访问任何属性
	- 对象的数据属性
	- 对象的方法


姓名： 马林

学习内容：lecture 8 一半内容

打卡天数：第26天

总共用时：约2h

欢迎学过的小伙伴们观看和提意见，温故而知新。欢迎即将要学到这节课的小伙伴浏览预习。

6/27/2019 8:47:17 PM 

## 怎样使用一个方法 ##
方法定义的格式
def distance(self, other): 

使用类：

1. 传统方式
c = Coordinate(3,4)
zero = Coordinate(0,0)
print(c.distance(zero))
print括号里的分别是	对象调用方法	方法的名字	参数不包括自我（自我表示的是c）

2. 相当于
c = Coordinate(3,4)
zero = Coordinate(0,0)
print(Coordinate.distance(c, zero))
print括号里的分别是	类的名字	方法的名字	参数

## 对象的打印表示 ##

1. 默认情况下**无法提供**信息的打印表示
2. 为类定义**__str__方法**
3. 当在类对象上使用print时，Python会调用__str__方法
4.  你选择它做什么！ 假设当我们打印一个Coordinate对象时，想要显示

c = Coordinate(3,4) 
print(c) 
<3,4>

## 定义自己的打印方法 ##

	def __str__(self):
	        """ 返回self的字符串表示形式 _str_是特殊方法的名称	一定返回一个字符串"""
	        return "<" + str(self.x) + "," + str(self.y) + ">"

## 在类型和类别周围缠绕你的头 ##

- 可以询问对象实例的类型
>>> c = Coordinate(3,4) 
>>> print(c) 
<3,4> 
返回_str_方法

>>> print(type(c)) 
<class __main__.Coordinate> 
返回对象c的类型

- 这是有道理的
>>> print(Coordinate)
<class __main__.Coordinate> 
坐标是一个类

>>> print(type(Coordinate)) 
<type 'type'> 
Coordinate类是一种对象

- 使用isinstance（）来检查对象是否是坐标
>>> print(isinstance(c, Coordinate)) True

## 特别经营者 ##
-  +, -, ==, <, >, len(), print, and many others

- 喜欢打印，可以覆盖这些与你的类一起工作

- 在前/后使用双下划线定义它们
__add__(self, other)  self + other 
__sub__(self, other)  self - other 
__eq__(self, other)  self == other 
__lt__(self, other)  self < other 
__len__(self)  len(self) 
__str__(self)  print self 
... and others

## 示例：分数 ##
- 创建一个**新类型**以将数字表示为分数
- **内部表示**是两个整数
	- 分子
	- 分母
- **接口**a.k.a.**方法**a.k.a如何与Fraction对象进行**交互**
	- 加，减
	- 打印表示，转换为浮点数
	- 反转分数
- 这个代码是在讲义中，检查出来！

## OOP的定义 ##
- 将共享的对象**捆绑**在一起
	- 常用属性和
	- 对这些属性进行操作的过程

- 使用**抽象**来区分如何实现对象与如何使用对象
- 构建从其他类对象继承行为的对象**抽象层**
- 在Python的基本类之上创建我们**自己的对象类**

抽象数据类型非常的重要，它可以衍生出一种组织大型程序的新思维方式。

在生物领域，人们谈论的蛋白质和残留物，这些概念，实际上是在脑海中搜集与这些对象有关的数据和特性，然后放在一块形成一个知识包。