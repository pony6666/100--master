6/8/2019 4:58:02 PM

## 快速回顾lecture3的内容 ##

上半场是对于字符串的操作，for 循环遍历字符串对象的循环，下半场可以实现不同的实现，找到立方根的问题， 检查和猜测，二分查找法（猜数字游戏）

## lecture4的内容梗概 ##
构建程序，隐藏代码。写出漂亮连贯的代码，写出可重复的使用的代码，通过隐藏一些代码中的详细信息，做这些事情需要一个叫做函数的东西。

因为如果要写大段的代码的话，它会变得非常的混乱，非常的快，。

如果你想成为一个优秀的程序员，一个好的编程风格不一定会添加很多很多的代码，但是可以为自己添加很多的功能块

## 我们应该怎样写代码 ##
目前
- 覆盖语言机制
- 知道如何为每次计算编写不同的文件
- 每个文件都是一段代码
- 每个代码都是一系列指令

这种方法存在的问题
- 容易出现小规模问题
- 对于较大的问题而言很麻烦
- 难以跟踪细节
- 您如何知道正确的信息提供给正确的代码部分

## 好的编程 ##
- 更多代码不一定是好事
- 通过功能量来衡量优秀的程序员
- 引入功能块实现分解和抽象的机制

## 示例 - 投影仪 ##
- 投影仪是一个黑盒子
- 不知道它是如何工作的
- 知道界面：输入/输出
- 连接任何可与该输入通信的电子
- 黑盒以某种方式将图像从输入源转换为墙壁，放大它
- **摘要想法**：不需要知道投影机如何使用它
- 为奥运会投影大图像分解为单独投影仪的单独任务
- 每台投影机接收输入并产生单独的输出
- 所有投影仪一起工作以产生更大的图像
- **分解想法**：不同的设备协同工作以实现最终目标

笔记，例子，投影仪，即使给你投影仪的所有原件，比如灯泡，风扇，电子元件，外壳等等的东西，谁又能在立即马上组建出一个投影仪呢？
但是，如果我给你一台完全组装的投影仪，和一台电脑，谁能一小时让他们一起工作呢？虽然我们不知道投影仪的内部构造，但是我们却能够使用它们。

所以说，投影仪就相当于一个黑匣子，你不需要知道其中的内部构造，而是知道怎样用它就可以了，这是一个很抽象的一个东西。

如果我想投影一个非常大的图案，这个图案有十个足球场那么大，那我应该怎么办，构造一个超级大的投影仪吗？这个有点不现实，但是，如果我们用很多的普通的小的投影仪呢？每个小的投影仪设置成投影出一个大图案的一部分，让它们共同组成一个大图案，这就是分解的的想法。

你拿同一个投影仪，喂它不同的输入，在幕后完成同样的事情，但它会完成不同的输出 ，所以这些不同的设备将在一起工作，实现相同共同的目标，这就是分解的i想法。

所以这些是应用于投影问题的地方，大图像。但是我们可以将相同的思想应用于计算机编程，所以分解就是问题的所在。

在代码中创建结构，在投影仪实例中，我们有单独的设备一起工作在一起。在编程中，实现分解，将代码划分成小块的，独立工作。

想象一下，有迷你型的超级小程序，你输入一点什么，它们就做一点任务，然后他们呢会给你一些回报。 

# 申请这些概念	TO PROGRAMMING #

## 用**DECOMPOSITION**创建结构 ##
1. 在投影仪示例中，单独的设备
2. 在编程中，将代码划分为**模块**
- 是*独立* 的
- 用于*分解* 代码
- 重要的是可*重复* 使用。你可以重复使用很多次，只要有不同的输入，就会有不同的输出，则
- 保持代码*有序性*
- 保持代码*连贯* 
3. 本讲座，实现功能**分解**
4. 在接下来的一段时间，用类来实现分解。使用类，你可以创建自己的对象类型，所以分解实在你的代码中创建结构

## 用**抽象**来压制细节 ##
1. 在投影仪示例中，如何使用它的说明就足够了，不需要知道如何构建它，在编程中他是相同的想法。
一旦你编写了一个小程序来执行一个小功能，你不需要多次重复编写那一段代码，这个东西就叫做函数规范。
这是一段告诉任何人的文字，谁想将来使用它，它可以告诉人们怎样去使用，它需要输入什么？输入的类型是什么？应该做的功能是什么？你将从中获得的输出是什么？只是一个功能块，你只需要知道，它的输入是什么，它做什么，什么是输出就能使用它了。
所以这些就是一些可以重复使用的代码块
2. 在编程中，将一段代码视为**黑盒子**
- 无法看到细节
- 不需要查看详细信息
- 不想查看详细信息
- 隐藏繁琐的编码细节
3. 使用**函数规范**或**docstrings**实现抽象

## 函数 ##
1. 编写可重用的代码/代码块，称为函数
2. 在程序中“**召唤**”或“**调用**”函数之前，函数不会在程序中运行
3. 函数的特性
- 有**名字**
- 有**参数**
- 有一个**docstring**
- 有**正文**
- **返回**一些东西

### 卡点docstring是什么意思 ###
直接Google翻译出来是，文档字符串，它充当的角色是对一个已经编写好的程序进行解释说明。

## 如何编写和调用/调用功能 ##
直接看那张ppt，所展示的格式非常的清晰

6/8/2019 6:08:09 PM  

6/8/2019 7:48:03 PM 

## 可变范围 ##
- **形式参数**在调用函数时绑定到**实际参数**的值
- 输入函数时创建的**新范围/框架/环境**
- 范围是名称到对象的映射

6/8/2019 9:02:39 PM 

姓名： 马林
学习内容：lecture4.前半部分
总共用时：约2.3小时
思维记录：下面的文件中是自己学习时的头脑中思维的变。自己比较喜欢记录自己的学习时头脑中的想的过程，以此来监控自己的大脑，一方面，方便自己理清思路，另一方面，方便自己沉浸式学习，避免大脑偷懒，不查找答案解决问题。

6/9/2019 8:45:00 AM 

## 一个警告：如果没有return语句 ##
将返回None，所以如果结果出现了None值的话，需要你检查一下是否写上了return语句

    `def f(x):
		    x=x+1
		    print('inf(x):x=',x)
		    return x 
	    
	x=3
	z=f(x)`
	
6/9/2019 9:02:34 AM 

6/9/2019 9:27:19 AM 

    `## Simple is_even function definition
	def is_even( i ):
	    """ 
	    Input: i, a positive int
	    Returns True if i is even, otherwise False
	    """
	    remainder = i % 2
	    return remainder == 0
	
	# Use the is_even function later on in the code
	print("All numbers between 0 and 20: even or not")
	for i in range(20):
	    if is_even(i):
	        print(i, "even")
	    else:
	        print(i, "odd")`

注意函数块的使用会使代码变得非常的好看

在python中，一切都是对象，整数使对象，小数是对象，甚至函数都是对象，因此，你可以来回传递传递对象作为参数，作为函数对象。作为函数参数，你也可以传递其他的参数，作为参数

在里面，老师强烈推荐了一种方法就是用纸和笔，理由是参考下面的一行代码

    def func_a():
	    print('inside func_a')
	
	def func_b(y):
	    print('inside func_b')
	    return y
	
	def func_c(z):
	    print('inside func_c')
	    return z()
	
	print(func_a())
	print(5+func_b(2))
	print(func_c(func_a))
结合那几张ppt的话，会更容易理解
如果，一步一步地写的话，还是非常容易理解的

## 范围例子 ##
### 卡点，下面这段话和其中的代码不明白什么意思 ###
在全球的范围内，当然可以有变量。当你在不同的范围内时，你可以拥有你想要的任何变量名称，当你进入那个范围的时候，python会使用那些变量。
它们根本不会互相干扰，代码如下

    def f(y):
	    x = 1
	    x += 1
	    print(x)
	x = 5
	f(x)
	print(x)
打印出来的结果是2 和5
这里面有一个初始化变量x=1
x=1是你定义一个函数时所用的一个名为x的变量，
x=5时函数之外所定义的，这是看三遍后理解的。

在看一段代码，和上面进行一个比较

    def g(y):
	    print(x)
	    print(x+1)
	x = 5
	g(x)
	print(x)
这段代码在定义函数里面是没有变量x的，python只能从外面找。

再看一段错误的代码

    def h(y):
	    x+=1
	    #x += 1 #leads to an error without line `global x` inside h
	x = 5
	h(x)
	print(x)
这段代码错的原因是，再定义函数里面没有全球变量，没有初始化变量

6/9/2019 10:37:11 AM 

6/9/2019 11:10:13 AM 

录制最后关于镶嵌函数的视频，方便以后反复观看。

6/9/2019 11:39:35 AM 

6/9/2019 2:12:51 PM 

接着做lecture4的练习题
做第一个练习题的时候，猛然发现，有一张ppt上关于return 和print函数的比较还没有看，

return

- return only has meaning **inside** a function 
- 在函数内只执行**一次**返回
- 函数内部在return后面的代码不执行
- 具有与之关联的值，**赋予函数调用者**

而print

- print can be used **outside** functions 
- can execute **many** print statements inside a function 
- code inside function can be executed after a print statement 
- 有一个与之关联的值，**输出到控制台**

下面一段函数，关于return和print

    def add(x,y):
	    return x+y
	
	def mult(x,y):
	    print(x*y)
	    
	add(1,2)
	print(add(1,2))
	mult(3,4)
	print(mult(4,5))
会出现4行结果
3
12
20
None
最后一个结果是自己运行程序后显示的
### 卡点为什么会出现None ###
print(mult(4,5)) 对应到是x=4,y=5带进去已经定义后的函数，则会print(4*5）=20，而又因为定义的这个函数没有return语句在里面，所以打印出来的东西是None

第二个练习题

    def sq(func,x):
	    y=x**2
	    return func(y)
	
	def f(x):
	    return x**2
	
	calc=sq(f,2)
	print(calc)

calc=sq(f,2)这是函数的调用，里面的f对应函数的func ，里面的2对应的是x.我们按顺序采用变量，将他们映射一下。它们的第一件事就是创建此变量，y=**2,所以最后得到y=4，然后返回的是func(4) ,这就相当于func(4)=f(4),所以现在是另一个参数调用的时候了，f(4)返回得到16。

做完了lecture4，然后在看一下这两天关于lecture4的记录

### 一个格式转换的问题 ###

引用代码和引用序列的时候，前一行一定得空行，不然有的代码不再代码方框内。
大致出现错误比较多的是关于return语句，当没有return的时候，返回的值的None.
定义完函数后，如果要进行调用给的话，仔细地看它们的对应关系，不要被变量的名称所迷惑

### 还有一个代码看后不懂，继续看一下视频 ###

    `def func_a():
	    print('inside func_a')
	
	def func_b(y):
	    print('inside func_b')
	    return y
	
	def func_c(z):
	    print('inside func_c')
	    return z()
	
	print(func_a())
	print(5+func_b(2))
	print(func_c(func_a))`

运行后的结果是

inside func_a
None
inside func_b
7
inside func_c
inside func_a
None

最后三行答案不是特别理解，打开视频后想大概定一个位置，办法是根据PPT选定位置，打开PPT后发现，可以看这段PPT来理解这个疑惑呀

print(func_a())中的func_a()没有参数
print(5+func_b(2))中的func_b(2)有一个参数2
print(func_c(func_a))中的func_c(func_a)有一个参数——另一个函数

因为func_a()没有return ，所以最后print出的是None
因为func_b(y)有return y ,所以func_b(2)会赋予函数调用者2，但是2不会输出到控制台。print(5+2)再控制台上得到7
因为func_c(func_a)会先运行第三个函数，所以根据定义会再控制台上打印一次inside func_c，括号里面的会参与形式func_a(),巧妙地出现了定义的第一个函数，所以控制台会打印一次inside func_a，然后由于第一个函数没有返回值，所以，打印出来的是None

结束
6/9/2019 3:59:56 PM 
姓名： 马林
学习内容：lecture4后半部分加上练习题
总共用时：约3.7小时
思维记录：下面的文件中是自己学习时的头脑中思维的变话。自己比较喜欢记录自己的学习时头脑中的想的过程，以此来监控自己的大脑，一方面，方便自己理清思路，另一方面，方便自己沉浸式学习，避免大脑偷懒，不查找答案解决问题。

	
