这几天，一在做实验，不过还得抽时间来听MIT Python课，并且写自己的学习笔记，话不多说开始吧。

一开始直接就讲了一个十分有意思的比喻

如果你现在正在做饭，土突然从天花板上掉下了几只只虫子，你会怎么做？

同学们的回答的思路也十分的丰富，有说先前直接盖上盖子，有说把虫子挑出来，有说直接对整个房子进行一次大扫除，甚至有的同学直接说吃掉，哈哈哈

老师也对各个答案进行了适当的分析，在汤里检查一下虫子——testing测试。先前直接盖上盖子相当于——defensive防御性程序设计。清理厨房——eliminate source of bugs消除虫子的来源

最后引出了今天的主题

# 测试，调试，异常，解决  #

## 防御性程序设计 ##

1. 编写**功能块**
2. **模块化**程序
3. 检查输入输出的**环境**

## 测试/验证 ##
1. 将输入/输出对与规范进行**比较**
2. “它不起作用！”
3. “我怎么能破坏我的程序？”

## 调试 ##
1. 研究导致错误的事件
2. “为什么它不起作用？”
3. “我该如何修复我的程序？”


姓名： 马林

学习内容：lecture7的小部分教程更新中。分享内容的整理

打卡天数：第22天

总共用时：约0.5小时+3小时

适用对象：没有基础的小白预习或基础薄弱的初学者复习

为优化小伙伴的观看体验，简化观看步骤，可以打开这连接观看

6/23/2019 1:24:03 PM 

> 测试和调试不是你编写玩程序以后才开始考虑的问题，优秀的程序员在设计程序时，就已经开始烤鱼如何使程序易于测试和调试了。

## 自我设置以便进行简单的测试和调试 ##
- 从一**开始**，设计代码就可以轻松实现这一部分
- 将程序分解为可以单独测试和调试的**模块**
- 文档对模块的**约束**
	你希望输进什么？你希望输出什么？
- 代码设计背后的文档假设

## 什么时候准备好测试？ ##
- 确保**代码运行**
	- 删除语法错误
	- 删除静态语义错误
	- Python解释器通常可以为您找到这些

- 有**一组预期的结果**
	- 输入集
	- 对于每个输入，预期输出

测试的关键是找到这样一组输入，可以称之为测试套件。它有很大可能发现程序错误，又不需要运行太长的时间。比如，对输入的两个整数就可以对所有的整数成对的组合，从正负可以分四种结果，从是不是零可以分三个结果，总共有7种结果


## 一类测试tests ##
- 单元测试
	- 验证每个程序
	- 分别测试每个功能

-  回归测试
	-  在找到错误时添加bug测试
	-  **抓住以前修复**的重新引入的错误

- 集成测试
	- 整体计划是否有效
	- 倾向于急于这样做

基于**代码**探索路径的启发式方法称为**白盒测试**。
基于**规范**探索路径的启发式方法称为**黑盒测试**。

## 黑盒测试 ##

理论上，进行黑盒测试时不需要查看要测试的代码。

6/23/2019 2:31:12 PM 

### 卡点 ——关于黑盒测试的重要的边界条件##

既然，理论上黑盒测试时不需要查看要测试的代码。那么，看一下下面，关于黑盒测试的一个重要的边界条件——别名

def copy(L1,L2):
	"""假设L1和L2是列表
	   使L2和L1元素相同"""
	删除L2中的所有元素
		删除L2中的第一个元素		这句话是在自己敲的过程中理解出来的
	向空列表L2添加L1中的元素
		L2.append（e）

多数情况是有效的，但L1和L2引用同一个列表时，它就失效了。如果测试套件中没有包括像copy（L,L)这样的函数调用，就永远不会发现这个错误。

就上面的这句话不理解，L1和L2怎样引用同一个列表，它为什么就失效了呢？是因为如果，L1=L2的话，那么就会出现错误。

### 继续卡点——列表 ###

什么是列表，它的形式是什么样的？

序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。
Python有6个序列的内置类型，但最常见的是列表和元组。
序列都可以进行的操作包括索引，切片，加，乘，检查成员。
此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。
列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。
列表的数据项不需要具有相同的类型
创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。、

## 白盒测试 ##

构建白盒测试套件，要比构建黑盒测试套件要容易许多

如果一个白盒测试套件可以测试程序中素有潜在路径，那我们就可以认为它是**路径**完备的。

因为路径完备程度取决于程序中循环的次数和递归深度。

而且即使一个路径完备的测试套件也不能保证发现程序中的所有错误。比如下下面的

def abs(x):
	"""假设x是整数
		如果x>=0返回x,否则返回-x"""
	if x<-1 :
		return -x
	else:
		return x

这里如果输入集合{2，-2}用来覆盖规范中的所有路径，这个测试看起来是一个完备的白盒测试套件，但是忽略了一个事实：abx(-1)会返回-1

白盒测试的参考价值

1. 测试所有if语句的所有分支
2. 必须测试每个except子句
3. 对于每一个for循环，需要一下测试用例

	- 未进入循环（例如，使用循环遍历列表中的所有元素，则必须测试空列表）
	- 循环体只被执行一次
	- 循环体只被执行多余一次

4. 对于每一个while循环：	
	- 包括上面for循环中的所有用例
	- 还要包括对应于所有跳出循环的方式的测试用例
5. 对于递归函数，测试用例应该包括函数没有递归调用就返回、只执行一次递归调用和执行多次递归调用的情况

## 执行测试 ##

测试一般分为两个阶段，单元测试和集成测试。如果集成测试没通过，那就还需要对单个模块做出修改（比如函数）

 ## 调试 ##
- steep learning curve 陡峭的学习曲线
- 目标是拥有一个无错误的程序
- 工具
	- 内置于IDLE和Anaconda
	- Python Tutor 
	- print statement 
	- 在你的狩猎中要系统化

## print语句 ##

1. 检验假设的好方法
2. when to print 
	- 输入函数
	- 参数
	- 函数结果
3. 使用二分法
	- 在代码的中间位置，用print检验
	- 根据值决定bug的位置


## 调试的步骤 ##
1. 学习程序代码
	- 不要问有什么问题
	- 问我是如何得到意想不到的结果的
	- 它是一个家庭的一部分吗？
2. 科学的方法
	- 学习先有的数据
	- 组织假设
	- 可重复的实验
	- 选择最简单的输入来测试

错误信息很容易获得 

## 逻辑错误 - 很难 ##
1. 在编写新代码之前要先思考
2. 画画，休息一下
3. 解释代码
	- 任何人
	- 甚至一只橡皮鸭

### 不要做的事情 ###

- 直接写下整个代码
- 测试整个代码
- 调试整个代码

- 直接改代码
- 记住代码出现错误的地方
- 测试代码
- 忘记bug和你的改正
- 恐慌

### 需要做的事情 ###

- 写一个功能块
- 测试功能块，调试功能块
- 再写一个功能块
- 再测试功能块，调试功能块
- 合并整个调试

- 备用代码块
- 改变代码块
- 写下潜在的bug
- 测试代码块
- 将新的代码块和旧的代码块作比较

## 异常和断言 ##

**异常**通常被定义为“不符合规范的东西”。在Python中，异常十分常见。

程序因为一个异常被抛出而终止时，我们称之为抛出了一个**未处理异常**

姓名： 马林

学习内容：lecture7的部分教程更新中。

打卡天数：第23天

总共用时：约4小时

适用对象：没有基础的小白预习或基础薄弱的初学者复习

为优化小伙伴的观看体验，简化观看步骤，可以打开这连接观看













